<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="d3-sankey-circular.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="example-data.js"></script>
  <script src="d3-tip.js"></script>




  <!-- <link href="https://fonts.googleapis.com/css?family=Roboto:100i" rel="stylesheet"> -->

  <title>Sankey Model for Cost of Quality</title>
  <style>
    body {
      font-family: monospace;
      /*background: #E3D4C1;*/
      /*background: #000;*/
    }

    rect {
      shape-rendering: crispEdges;
    }

    text {
      /*text-shadow: 0 1px 0 #fff;*/
      font-size: 12px;
      /*font-family: 'Roboto', sans-serif;*/
      font-family: monospace;
      /*fill: white;*/
    }
    .plotlytitles {
      font-size: 16px;
      font-family: monospace;
      color: black

    }

    .link {
      fill: none;
    }

    svg {
      /* position: absolute; */
    }

    canvas {
      position: absolute;
      pointer-events: none;
    }

    /* pie chart css */
    .outer-label {
      color: rgba(0, 0, 0, 0.8);
      font-size: 12px;
      font-family: monospace;
      text-align: center;
    }

    .center {
      font-size: 18px;
      text-transform: uppercase;
      /* fill: #fff; */
    }

    path {
      cursor: pointer;
    }

    #graph-container,
    #barcharts_div {
      display: inline;
    }

    #plotly_COQ,
    #plotly_ind {
      display: inline;
    }

    .d3-tip {
      line-height: 1;
      padding: 6px;
      background: cornsilk;
      color: rgba(0, 0, 0, 0.8);
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }

    
    /* @-webkit-keyframes scale-up {
    from { @include transform(scale(0.95)); opacity: 0; }
    to { @include transform(scale(1)); opacity: 1; }
} */
  </style>
</head>

<body>

  <h1>Sankey Model of Cost of Quality</h1>


  <div id="block container">
    <div id="sankey"> <canvas width="1000" height="530"></canvas>
      <svg width="1000" height="100"></svg>
    </div>

    <svg id="Bullet_titles" width="1000" height="20"></svg>
      <!-- <div class="row">
        <div class="col-md-5">
          <div id="defectBullet_title" class="plotlytitles">
            <center><u>Defective Unit Counter</u></center>
          </div>
        </div>
        <div class="col-md-5">
          <div id="coqBullet_title" class="plotlytitles">
            <center><u>Cost of Quality (COQ) as % of Net Sales</u></center>
          </div>
        </div>
      </div>-->
      <div id=plotly_COQ> </div>

    
    <!-- <div class="col"> -->
    <div id="barcharts_div">
      <svg id="barcharts" width="530" height="500"></svg>
      <svg id="graph-container" width="400" height="500"></svg>
    </div>

    <!-- <div class = "col"> -->
    <!-- <div id="graph-container"></div> -->
  </div>

  <script>

    // var margin = { top: 150, right: 100, bottom: 130, left: 120 };
    var margin = { top: 0, right: 100, bottom: 50, left: 0 };
    var width = 1000;
    var height = 300;

    let data = data2;

    const nodePadding = 40;

    const circularLinkGap = 2;


    var sankey = d3.sankey()
      .nodeWidth(10)
      .nodePadding(nodePadding)
      .nodePaddingRatio(0.9)
      .scale(0.5)
      .size([width, height])
      .nodeId(function (d) {
        return d.name;
      })
      .nodeAlign(d3.sankeyCenter)
      // .nodeAlign(d3.sankeyLeft)
      // .nodeAlign(d3.sankeyRight)
      // .nodeAlign(d3.sankeyJustify)
      .iterations(1);
    // console.log(sankey)

    // var svg = d3.select("#chart").append("svg")


    var svg = d3.select("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom);

    var g = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

    var linkG = g.append("g")
      .attr("class", "links")
      .attr("fill", "none")
      .attr("stroke-opacity", 0.2)
      .selectAll("path");

    var nodeG = g.append("g")
      .attr("class", "nodes")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10)
      .selectAll("g");

    //run the Sankey + circular over the data
    let sankeyData = sankey(data);
    let sankeyNodes = sankeyData.nodes;
    let sankeyLinks = sankeyData.links;

    let depthExtent = d3.extent(sankeyNodes, function (d) { return d.depth; });

    //Uses gradient to create node color
    // var nodeColour = d3.scaleSequential(d3.interpolateCool)
    //  .domain([0,width]);

    //Creates color based on COQ components
    const colorLookup = {
      "COGQ": "DarkSeaGreen",
      "COPQ": "LightCoral",
      "Prevention": "blue",
      "Appraisal": "purple",
      "Internal Failure": "orange",
      "External Failure": "red",
      "Shipping": "gray",
      "End User": "green"
    }


    //Adjust link Y coordinates based on target/source Y positions

    var node = nodeG.data(sankeyNodes)
      .enter()
      .append("g");
    console.log(node)






    node.append("rect")
      .attr("x", function (d) { return d.x0; })
      .attr("y", function (d) { return d.y0; })
      .attr("height", function (d) { return d.y1 - d.y0; })
      .attr("width", function (d) { return d.x1 - d.x0; })
      .style("fill", function (d) { return (colorLookup[d.COQ]); })
      .style("opacity", 0.5)
      .on("mouseover", function (d) {

        let thisName = d.name;

        node.selectAll("rect")
          .style("opacity", function (d) {
            return highlightNodes(d, thisName)
          })

        d3.selectAll(".sankey-link")
          .style("opacity", function (l) {
            return l.source.name == thisName || l.target.name == thisName ? 1 : 0.3;
          })

        node.selectAll("text")
          .style("opacity", function (d) {
            return highlightNodes(d, thisName)
          })
      })
      .on("mouseout", function (d) {

        node.selectAll("rect").style("opacity", 0.5);
        d3.selectAll(".sankey-link").style("opacity", 0.7);
        node.selectAll("text").style("opacity", 1);
      })

    node.append("text")
      .attr("x", function (d) { return (d.x0 + d.x1) / 2; })
      .attr("y", function (d) { return d.y0 - 12; })
      .attr("dy", "0.35em")
      .attr("text-anchor", "start")
      .text(function (d) { return d.name; });

    // adds tooltip on hover over node rectangles.
    node.append("title")
      .text(function (d) { return d.name + "\n" + "$" + (d.cost) + "/unit"; });
    console.log(node)

    var link = linkG.data(sankeyLinks)
      .enter()
      .append("g")

    link.append("path")
      .attr("class", "sankey-link")
      .attr("d", sankeyPath)
      .style("stroke-width", function (d) { return Math.max(1, d.width); })
      .style("opacity", 0.7)
      .style("stroke", function (link, i) {
        if (link.optimal === "yes") { return "black" } else { return "red" }
      })
      .attr("id", function (d) { return "path-" + d.level })


    link.append("title")
      .text(function (d) {
        return d.source.name + " â†’ " + d.target.name + "\n Index: " + (d.index);
      });


    //ARROWS
    // var arrowsG = linkG.data(sankeyLinks)
    //   .enter()
    //   .append("g")
    //   .attr("class", "g-arrow")
    //   .call(appendArrows, 10, 10, 4) //arrow length, gap, arrow head size

    // arrowsG.selectAll("path")
    //   .style("stroke-width", "10")
    //   //.style("stroke-dasharray", "10,10")

    //   arrowsG.selectAll(".arrow-head").remove()

    // let duration = 5
    // let maxOffset = 10;
    // let percentageOffset = 1;

    //     //https://stackoverflow.com/questions/35556876/javascript-repeat-a-function-x-amount-of-times
    //     function runFunctionXTimes(callback, interval, repeatTimes) {
    //     let repeated = 0;
    //     const intervalTask = setInterval(doTask, interval)

    //     function doTask() {
    //         if ( repeated < repeatTimes ) {
    //             callback()
    //             repeated += 1
    //         } else {
    //             clearInterval(intervalTask)
    //         }
    //     }
    // } 
    //

    // var animateDash = setInterval(updateDash, duration);
    // runFunctionXTimes(updateDash,duration,5)


    // function updateDash() {

    //   arrowsG.selectAll("path")
    //   .style("stroke-dashoffset", percentageOffset * maxOffset)

    //   percentageOffset = percentageOffset == 0 ? 1 : percentageOffset - 0.01
    //   // percentageOffset = percentageOffset == 0.5 
    // }

    function highlightNodes(node, name) {

      let opacity = 0.3

      if (node.name == name) {
        opacity = 1;
      }
      node.sourceLinks.forEach(function (link) {
        if (link.target.name == name) {
          opacity = 1;
        };
      })
      node.targetLinks.forEach(function (link) {
        if (link.source.name == name) {
          opacity = 1;
        };
      })

      return opacity;

    }




  </script>
  <!-- <script src="d3.sankey.js"></script> -->
  <script src="drilldownpie.js"></script>
  <script src="draw-units.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- <script src="Scorecard.js"></script> -->
  <script src="Scorecard_subplots.js"></script>
</body>

</html>